(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-6cead7d4"],{"18c6":function(e,t,n){"use strict";n.d(t,"a",(function(){return O})),n.d(t,"b",(function(){return R})),n.d(t,"c",(function(){return F})),n.d(t,"d",(function(){return D})),n.d(t,"e",(function(){return A})),n.d(t,"f",(function(){return V})),n.d(t,"g",(function(){return w})),n.d(t,"h",(function(){return E}));var i=n("ce50"),a=n("c84e"),r=n("9b77");function o(e,t){const n=a["e"].SIZE_FIELD_STOPS|a["e"].SIZE_MINMAX_VALUE|a["e"].SIZE_SCALE_STOPS|a["e"].SIZE_UNIT_VALUE,i=(e&(a["f"].FIELD_TARGETS_OUTLINE|a["f"].MINMAX_TARGETS_OUTLINE|a["f"].SCALE_TARGETS_OUTLINE|a["f"].UNIT_TARGETS_OUTLINE))>>>4;return t.isOutline||t.isOutlinedFill?n&i:n&~i}const l=0,s=8,d=7,u=8,c=11,v=11,f=12,m=13,_=14,p=15,h=15,g=16,y=17,S=18,x=19,T=20,I=21,b=22;function w(e,t){switch(e){case a["d"].FILL:return O.from(t);case a["d"].LINE:return F.from(t);case a["d"].MARKER:return D.from(t);case a["d"].TEXT:return V.from(t);case a["d"].LABEL:return R.from(t);default:throw new Error("Unable to createMaterialKey for unknown geometryType "+e)}}function E(e){switch(A.load(e).geometryType){case a["d"].MARKER:return new D(e);case a["d"].FILL:return new O(e);case a["d"].LINE:return new F(e);case a["d"].TEXT:return new V(e);case a["d"].LABEL:return new R(e)}}class A{constructor(e){this._data=0,this._data=e}static load(e){const t=this.shared;return t.data=e,t}set data(e){this._data=e}get data(){return this._data}get geometryType(){return this.bits(u,c)}set geometryType(e){this.setBits(e,u,c)}get mapAligned(){return!!this.bit(T)}set mapAligned(e){this.setBit(T,e)}get sdf(){return!!this.bit(v)}set sdf(e){this.setBit(v,e)}get pattern(){return!!this.bit(f)}set pattern(e){this.setBit(f,e)}get textureBinding(){return this.bits(l,s)}set textureBinding(e){this.setBits(e,l,s)}get geometryTypeString(){switch(this.geometryType){case a["d"].FILL:return"fill";case a["d"].MARKER:return"marker";case a["d"].LINE:return"line";case a["d"].TEXT:return"text";case a["d"].LABEL:return"label";default:throw new i["a"]("Unable to handle unknown geometryType: "+this.geometryType)}}setBit(e,t){const n=1<<e;t?this._data|=n:this._data&=~n}bit(e){return(this._data&1<<e)>>e}setBits(e,t,n){for(let i=t,a=0;i<n;i++,a++)this.setBit(i,0!=(e&1<<a))}bits(e,t){let n=0;for(let i=e,a=0;i<t;i++,a++)n|=this.bit(i)<<a;return n}hasVV(){return!1}setVV(e,t){}getVariation(){return{mapAligned:this.mapAligned,pattern:this.pattern,sdf:this.sdf}}getVariationHash(){return this._data&~(d&this.textureBinding)}}A.shared=new A(0);const z=e=>class extends e{get vvSizeMinMaxValue(){return 0!==this.bit(g)}set vvSizeMinMaxValue(e){this.setBit(g,e)}get vvSizeScaleStops(){return 0!==this.bit(y)}set vvSizeScaleStops(e){this.setBit(y,e)}get vvSizeFieldStops(){return 0!==this.bit(S)}set vvSizeFieldStops(e){this.setBit(S,e)}get vvSizeUnitValue(){return 0!==this.bit(x)}set vvSizeUnitValue(e){this.setBit(x,e)}hasVV(){return super.hasVV()||this.vvSizeMinMaxValue||this.vvSizeScaleStops||this.vvSizeFieldStops||this.vvSizeUnitValue}setVV(e,t){super.setVV(e,t);const n=o(e,t)&e;this.vvSizeMinMaxValue=!!(n&a["e"].SIZE_MINMAX_VALUE),this.vvSizeFieldStops=!!(n&a["e"].SIZE_FIELD_STOPS),this.vvSizeUnitValue=!!(n&a["e"].SIZE_UNIT_VALUE),this.vvSizeScaleStops=!!(n&a["e"].SIZE_SCALE_STOPS)}},C=e=>class extends e{get vvRotation(){return 0!==this.bit(p)}set vvRotation(e){this.setBit(p,e)}hasVV(){return super.hasVV()||this.vvRotation}setVV(e,t){super.setVV(e,t),this.vvRotation=!t.isOutline&&!!(e&a["e"].ROTATION)}},L=e=>class extends e{get vvColor(){return 0!==this.bit(m)}set vvColor(e){this.setBit(m,e)}hasVV(){return super.hasVV()||this.vvColor}setVV(e,t){super.setVV(e,t),this.vvColor=!t.isOutline&&!!(e&a["e"].COLOR)}},M=e=>class extends e{get vvOpacity(){return 0!==this.bit(_)}set vvOpacity(e){this.setBit(_,e)}hasVV(){return super.hasVV()||this.vvOpacity}setVV(e,t){super.setVV(e,t),this.vvOpacity=!t.isOutline&&!!(e&a["e"].OPACITY)}};class O extends(L(M(z(A)))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a["d"].FILL,t.dotDensity="dot-density"===e.stride.fill,t.simple="simple"===e.stride.fill,t.outlinedFill=e.isOutlinedFill,t.dotDensity||t.setVV(e.vvFlags,e),t.data}getVariation(){return{...super.getVariation(),dotDensity:this.dotDensity,outlinedFill:this.outlinedFill,simple:this.simple,vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}get dotDensity(){return!!this.bit(h)}set dotDensity(e){this.setBit(h,e)}get simple(){return!!this.bit(b)}set simple(e){this.setBit(b,e)}get outlinedFill(){return!!this.bit(I)}set outlinedFill(e){this.setBit(I,e)}}O.shared=new O(0);class D extends(L(M(C(z(A))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a["d"].MARKER,t.setVV(e.vvFlags,e),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvRotation:this.vvRotation,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}D.shared=new D(0);class F extends(L(M(z(A)))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a["d"].LINE,t.setVV(e.vvFlags,e),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}F.shared=new F(0);class V extends(L(M(C(z(A))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a["d"].TEXT,t.setVV(e.vvFlags,e),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvRotation:this.vvRotation,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}V.shared=new V(0);class R extends(z(A)){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=a["d"].LABEL,t.setVV(e.vvFlags,e),t.mapAligned=Object(r["a"])(e.placement),t.data}getVariation(){return{...super.getVariation(),vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}R.shared=new R(0)},"361b":function(e,t,n){"use strict";n.d(t,"a",(function(){return b}));n("7ce4"),n("d267");var i=n("8e37"),a=(n("d17d"),n("a1ff"),n("0fa6"),n("c120"),n("1956"),n("9f8b"),n("d45f")),r=n("49f0");const o={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = mod(v_accumulatedDistance / (v_patternSize.x * v_widthRatio), 1.0);\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = mod((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio), 1.0);\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * v_lineHalfWidth;\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};function l(e){let t=o;return e.split("/").forEach(e=>{t&&(t=t[e])}),t}const s=new r["a"](l);function d(e){return s.resolveIncludes(e)}const u=e=>Object(a["b"])({ID:e.id,PATTERN:e.pattern}),c={shaders:e=>({vertexShader:u(e)+d("background/background.vert"),fragmentShader:u(e)+d("background/background.frag")})},v=e=>Object(a["b"])({ID:e.id}),f={shaders:e=>({vertexShader:v(e)+d("circle/circle.vert"),fragmentShader:v(e)+d("circle/circle.frag")})},m=e=>Object(a["b"])({ID:e.id,PATTERN:e.pattern}),_={shaders:e=>({vertexShader:m(e)+d("fill/fill.vert"),fragmentShader:m(e)+d("fill/fill.frag")})},p=e=>Object(a["b"])({ID:e.id}),h={shaders:e=>({vertexShader:p(e)+d("outline/outline.vert"),fragmentShader:p(e)+d("outline/outline.frag")})},g=e=>Object(a["b"])({ID:e.id,SDF:e.sdf}),y={shaders:e=>({vertexShader:g(e)+d("icon/icon.vert"),fragmentShader:g(e)+d("icon/icon.frag")})},S=e=>Object(a["b"])({ID:e.id,PATTERN:e.pattern,SDF:e.sdf}),x={shaders:e=>({vertexShader:S(e)+d("line/line.vert"),fragmentShader:S(e)+d("line/line.frag")})},T=e=>Object(a["b"])({ID:e.id}),I={shaders:e=>({vertexShader:T(e)+d("text/text.vert"),fragmentShader:T(e)+d("text/text.frag")})};class b{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,t,n){const a=t.key<<3|this._getMaterialOptionsValue(t.type,n);if(this._programByKey.has(a))return this._programByKey.get(a);const r=this._getProgramTemplate(t.type),{shaders:o}=r,{vertexShader:l,fragmentShader:s}=o(n),d=t.getShaderHeader(),u=t.getShaderMain(),c=l.replace("#pragma header",d).replace("#pragma main",u),v=new i["a"](e,c,s,t.getAttributeLocations());return this._programByKey.set(a,v),v}_getMaterialOptionsValue(e,t){switch(e){case 0:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 1:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 2:return t.id?1:0;case 3:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1|(e.id?1:0)}case 4:{const e=t;return(e.sdf?1:0)<<1|(e.id?1:0)}case 5:return t.id?1:0;case 6:return t.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case 0:return c;case 5:return f;case 1:return _;case 4:return y;case 3:return x;case 2:return h;case 6:return I;default:return null}}}},"9b77":function(e,t,n){"use strict";function i(e){switch(e){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}n.d(t,"a",(function(){return i}))},a9a2:function(e,t,n){"use strict";n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return r})),n.d(t,"c",(function(){return l})),n.d(t,"d",(function(){return s}));var i=n("d114");function a(e,t){return Array.isArray(t)?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3]):(e[0]=t.r,e[1]=t.g,e[2]=t.b,e[3]=t.a),e}function r(e,t=0,n=!1){const i=e[t+3];return e[t+0]*=i,e[t+1]*=i,e[t+2]*=i,n||(e[t+3]*=255),e}function o(e){return r(a([],e))}function l(e){if(!e)return 0;const{r:t,g:n,b:a,a:r}=e;return Object(i["b"])(t*r,n*r,a*r,255*r)}function s(e){if(!e)return 0;const[t,n,a,r]=e;return Object(i["b"])(t*(r/255),n*(r/255),a*(r/255),r)}},c84e:function(e,t,n){"use strict";var i,a,r,o,l,s,d;n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return r})),n.d(t,"d",(function(){return i})),n.d(t,"e",(function(){return l})),n.d(t,"f",(function(){return s})),function(e){e[e.FILL=0]="FILL",e[e.LINE=1]="LINE",e[e.MARKER=2]="MARKER",e[e.TEXT=3]="TEXT",e[e.LABEL=4]="LABEL"}(i||(i={})),function(e){e[e.SUCCEEDED=0]="SUCCEEDED",e[e.FAILED_OUT_OF_MEMORY=1]="FAILED_OUT_OF_MEMORY"}(a||(a={})),function(e){e[e.NONE=0]="NONE",e[e.MAP=1]="MAP",e[e.LABEL=2]="LABEL",e[e.LABEL_ALPHA=4]="LABEL_ALPHA",e[e.HITTEST=8]="HITTEST",e[e.HIGHLIGHT=16]="HIGHLIGHT",e[e.CLIP=32]="CLIP",e[e.DEBUG=64]="DEBUG",e[e.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(r||(r={})),function(e){e[e.SIZE=0]="SIZE",e[e.COLOR=1]="COLOR",e[e.OPACITY=2]="OPACITY",e[e.ROTATION=3]="ROTATION"}(o||(o={})),function(e){e[e.NONE=0]="NONE",e[e.OPACITY=1]="OPACITY",e[e.COLOR=2]="COLOR",e[e.ROTATION=4]="ROTATION",e[e.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",e[e.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",e[e.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",e[e.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(l||(l={})),function(e){e[e.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",e[e.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",e[e.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",e[e.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(s||(s={})),function(e){e[e.SPRITE=0]="SPRITE",e[e.GLYPH=1]="GLYPH"}(d||(d={}))},c8dd:function(e,t,n){"use strict";n.d(t,"a",(function(){return k})),n.d(t,"b",(function(){return D})),n.d(t,"c",(function(){return F})),n.d(t,"d",(function(){return se})),n.d(t,"e",(function(){return B})),n.d(t,"f",(function(){return H})),n.d(t,"g",(function(){return q})),n.d(t,"h",(function(){return $})),n.d(t,"i",(function(){return P})),n.d(t,"j",(function(){return N})),n.d(t,"k",(function(){return le})),n.d(t,"l",(function(){return G})),n.d(t,"m",(function(){return W})),n.d(t,"n",(function(){return w})),n.d(t,"o",(function(){return ee})),n.d(t,"p",(function(){return U})),n.d(t,"q",(function(){return ie})),n.d(t,"r",(function(){return V})),n.d(t,"s",(function(){return te})),n.d(t,"t",(function(){return Q})),n.d(t,"u",(function(){return R})),n.d(t,"v",(function(){return ne})),n.d(t,"w",(function(){return re})),n.d(t,"x",(function(){return J})),n.d(t,"y",(function(){return ae})),n.d(t,"z",(function(){return oe})),n.d(t,"A",(function(){return O}));var i=n("ce50"),a=n("e92d"),r=(n("38a4"),n("a915"),n("a9a2"),n("c84e")),o=n("ecd7");class l{constructor(){this.color=[0,0,0,0],this.haloColor=[0,0,0,0],this.haloSize=0,this.size=12,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}acquire(e,t,n,i,a,r,o,l,s){this.color=e,this.haloColor=t,this.haloSize=n,this.size=i,this.angle=a,this.offsetX=r,this.offsetY=o,this.hAnchor=l,this.vAnchor=s}release(){this.color[0]=this.color[1]=this.color[2]=this.color[3]=0,this.haloColor[0]=this.haloColor[1]=this.haloColor[2]=this.haloColor[3]=0,this.haloSize=0,this.size=0,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}}l.pool=new o["a"](l);n("a1ff");const s=a["a"].getLogger("esri.views.2d.engine.webgl.Utils"),d="geometry",u=[{name:d,strideInBytes:36,divisor:0}],c=[{name:d,strideInBytes:32,divisor:0}],v=[{name:d,strideInBytes:20,divisor:0}],f=[{name:d,strideInBytes:12,divisor:0}],m=[{name:d,strideInBytes:40,divisor:0}],_=[{name:d,strideInBytes:36,divisor:0}],p=[{name:d,strideInBytes:36,divisor:0}];function h(e){const t={};for(const n of e)t[n.name]=n.strideInBytes;return t}const g=h(u),y=h(c),S=h(v),x=h(f),T=h(m),I=h(_),b=h(p);function w(e,{fill:t}){switch(e){case r["d"].MARKER:return g;case r["d"].FILL:return"dot-density"===t?x:"simple"===t?S:y;case r["d"].LINE:return T;case r["d"].TEXT:return I;case r["d"].LABEL:return b}}const E=[d],A=[d],z=[d],C=[d],L=[d];function M(e){switch(e){case r["d"].MARKER:return E;case r["d"].FILL:return A;case r["d"].LINE:return z;case r["d"].TEXT:return C;case r["d"].LABEL:return L}}function O(e){switch(e%4){case 0:case 2:return 4;case 1:case 3:return 1}}function D(e,t){switch(t%4){case 0:case 2:return new Uint32Array(Math.floor(e*t/4));case 1:case 3:return new Uint8Array(e*t)}}function F(e,t){switch(t%4){case 0:case 2:return new Uint32Array(e);case 1:case 3:return new Uint8Array(e)}}function V(e){return null!=e}function R(e){return"number"==typeof e}function P(e){switch(e){case"butt":return 0;case"round":return 1;case"square":return 2;default:return s.error(new i["a"]("mapview-invalid-type",`Cap type ${e} is not a valid option. Defaulting to round`)),1}}function N(e){switch(e){case"miter":return 2;case"bevel":return 0;case"round":return 1;default:return s.error(new i["a"]("mapview-invalid-type",`Join type ${e} is not a valid option. Defaulting to round`)),1}}function U(e){switch(e){case"opacity":return r["b"].OPACITY;case"color":return r["b"].COLOR;case"rotation":return r["b"].ROTATION;case"size":return r["b"].SIZE;default:return s.error("Cannot interpret unknown vv: "+e),null}}function B(e,t,n,i,a,r,o){for(const s in r){const t=r[s].stride,i=O(t),o=r[s].data,l=n[s].data,d=t*a.vertexCount/i,u=t*e/i,c=t*a.vertexFrom/i;for(let e=0;e<d;++e)l[e+u]=o[e+c]}const l=a.indexCount;for(let s=0;s<l;++s)i[s+t]=o[s+a.indexFrom]-a.vertexFrom+e}const k={[d]:35044};function H(e,t){const n=[];for(let i=0;i<5;++i){const a=M(i),r={};for(const e of a)r[e]={data:t(i,e)};n.push({data:e(i),buffers:r})}return n}function X(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5126:case 5124:case 5125:return 4}}function W(e){switch(e){case 5121:return 1;case 32819:return 2;case 5126:return 4;default:return void s.error(new i["a"]("webgl-utils","Unable to handle type "+e))}}function G(e){switch(e){case 5121:return Uint8Array;case 32819:return Uint16Array;case 5126:return Float32Array;default:return void s.error(new i["a"]("webgl-utils","Unable to handle type "+e))}}function Y(e){const t={};for(const n in e){const i=e[n];let a=0;t[n]=i.map(e=>{const t={...e,normalized:e.normalized||!1,divisor:e.divisor||0,offset:a,stride:0};return a+=e.count*X(e.type),t}),t[n].forEach(e=>e.stride=a)}return t}const Z=e=>{const t=new Map;for(const n in e)for(const i of e[n])t.set(i.name,i.location);return t},K=e=>{const t={};for(const n in e){const i=e[n];t[n]=i.length?i[0].stride:0}return t},j=new Map,q=(e,t)=>{if(!j.has(e)){const n=Y(t),i={strides:K(n),bufferLayouts:n,attributes:Z(t)};j.set(e,i)}return j.get(e)};function $(e){e(r["d"].FILL),e(r["d"].LINE),e(r["d"].MARKER),e(r["d"].TEXT),e(r["d"].LABEL)}const J=e=>"path"in e&&de(e.path),Q=e=>"url"in e&&e.url||"imageData"in e&&e.imageData,ee=e=>"imageData"in e&&e.imageData&&"contentType"in e&&e.contentType?`data:${e.contentType};base64,${e.imageData}`:"url"in e?e.url:null,te=e=>"url"in e&&e.url&&e.url.includes(".gif")||"contentType"in e&&"image/gif"===e.contentType||"imageData"in e&&e.imageData.includes("data:image/gif"),ne=e=>"url"in e&&e.url&&e.url.includes(".png")||"contentType"in e&&"image/png"===e.contentType||"imageData"in e&&e.imageData.includes("data:image/png"),ie=e=>e.type&&-1!==e.type.toLowerCase().indexOf("3d");function ae(e){switch(e.type){case"line":{const t=e;return"CIMSolidStroke"===t.cim.type&&!t.dashTemplate}case"fill":return"CIMSolidFill"===e.cim.type;case"esriSFS":return"esriSFSSolid"===e.style||"esriSFSNull"===e.style;case"esriSLS":return"esriSLSSolid"===e.style||"esriSLSNull"===e.style;default:return!1}}const re=e=>e.includes("data:image/svg+xml");function oe(e){switch("cim"in e?e.cim.type:e.type){case"esriSMS":case"esriPMS":case"CIMPointSymbol":case"CIMVectorMarker":case"CIMPictureMarker":case"CIMCharacterMarker":return!1;default:return!0}}function le(e){const t="maxVVSize"in e&&e.maxVVSize,n="width"in e&&e.width||"size"in e&&e.size||0;return t||n}function se(e){const t=[];for(let n=0;n<e.length;n++)t.push(e.charCodeAt(n));return t}const de=e=>!!e&&(e=e.trim(),!!(/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(e)&&/[\dz]$/i.test(e)&&e.length>4))}}]);
//# sourceMappingURL=chunk-6cead7d4.16b3e26e.js.map